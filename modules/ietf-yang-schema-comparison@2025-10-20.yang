module ietf-yang-schema-comparison {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-yang-schema-comparison";
  prefix schema-cmp;

  import ietf-yang-types {
    prefix yang;
    reference
      "RFC 6991: Common YANG Data types";
  }
  import ietf-yang-library {
    prefix yanglib;
    reference
      "RFC 8525: YANG Library";
  }
  import ietf-yang-structure-ext {
    prefix sx;
    reference
      "RFC 8791: YANG Data Structure Extensions";
  }

  organization
    "IETF NETMOD (Network Modeling) Working Group";

  contact
    "WG List: NETCONF WG list <mailto:netmod@ietf.org>
     WG Web:  https://datatracker.ietf.org/wg/netmod

     Author:  Michal Va≈°ko
              <mailto:mvasko@cesnet.cz>

     Author:  Rob Wilton
              <mailto:rwilton@cisco.com>

     Author:  Per Andersson
              <mailto:per.ietf@ionio.se>";

  description
    "This YANG 1.1 module contains definitions and extensions to
     support comparison between different versions of YANG schemas. The
     output of the comparison algorithm is described in this YANG module.
     The base schema nodes describe changes in a compiled YANG module
     with all of its included submodules and imported modules. The rest
     of the schema nodes are optional and describe changes in all the
     statements of a single YANG module.

     Copyright (c) 2025 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with
     or without modification, is permitted pursuant to, and
     subject to the license terms contained in, the Revised
     BSD License set forth in Section 4.c of the IETF Trust's
     Legal Provisions Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC
     itself for full legal notices.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document
     are to be interpreted as described in BCP 14 (RFC 2119)
     (RFC 8174) when, and only when, they appear in all
     capitals, as shown here.";
  // RFC Ed.: update the date below with the date of RFC publication
  // and remove this note.
  // RFC Ed.: replace XXXX (inc above) with actual RFC number and
  // remove this note.

  revision 2025-10-20 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: YANG Schema Comparison";
  }

  extension backwards-compatible {
    description
      "Marks statements in a new revision of a module
       that were changed but in a backwards-compatible
       manner according to YANG 1.1 and 1.0 rules for
       updating a module.

       When used as a substatement of a 'pattern'
       statement, it means its allowed value space has
       been expanded.

       When used as a substatement of a 'when' or
       'must' statement, it means their constraint has
       been relaxed.

       When used as a substatement of a 'description'
       statement, it means it has been changed in a
       backwards-compatible way.

       When used as a substatement of an extension
       instance, it means adding, modifying, or removing
       it is a backwards-compatible change.

       Not allowed to be instiantiated for any other
       statements.";
    reference
      "RFC 7950: The YANG 1.1 Data Modeling Language, section 11;
       RFC 6020: YANG - A Data Modeling Language for the Network
       Configuration Protocol (NETCONF), section 10";
  }

  feature parsed-schema {
    description
      "Compare also the statements removed from the compiled schema to get all
       the backwards-compatible and non-backwards-compatible changes possible
       for a YANG module.";
    reference
      "RFC 7950: The YANG 1.1 Data Modeling Language, section 11;
       RFC 6020: YANG - A Data Modeling Language for the Network
       Configuration Protocol (NETCONF), section 10";
  }

  typedef schema-path {
    type string;
    description
      "Node schema path (node-id). A generic type is used to not enforce their
       evaluation or validation in this context.";
  }

  typedef stmt-type {
    type enumeration {
      enum "base" {
        description
          "YANG statement 'base'.";
      }
      enum "bit" {
        description
          "YANG statement 'bit'.";
      }
      enum "config" {
        description
          "YANG statement 'config'.";
      }
      enum "contact" {
        description
          "YANG statement 'contact'.";
      }
      enum "default" {
        description
          "YANG statement 'default'.";
      }
      enum "description" {
        description
          "YANG statement 'description'.";
      }
      enum "enum" {
        description
          "YANG statement 'enum'.";
      }
      enum "error-app-tag" {
        description
          "YANG statement 'error-app-tag'.";
      }
      enum "error-message" {
        description
          "YANG statement 'error-message'.";
      }
      enum "extension-instance" {
        description
          "Any extension instance YANG statement.";
      }
      enum "fraction-digits" {
        description
          "YANG statement 'fraction-digits'.";
      }
      enum "identity" {
        description
          "YANG statement 'identity'.";
      }
      enum "length" {
        description
          "YANG statement 'length'.";
      }
      enum "mandatory" {
        description
          "YANG statement 'mandatory'.";
      }
      enum "max-elements" {
        description
          "YANG statement 'max-elements'.";
      }
      enum "min-elements" {
        description
          "YANG statement 'min-elements'.";
      }
      enum "must" {
        description
          "YANG statement 'must'.";
      }
      enum "node" {
        description
          "YANG statement 'container', 'leaf', 'leaf-list', 'list', 'anydata',
           'anyxml', 'rpc', 'action', or 'notification'. If the parsed schema
           is also compared, it can additionally be 'choice', 'case', 'uses' or
           'grouping'.";
      }
      enum "ordered-by" {
        description
          "YANG statement 'ordered-by'.";
      }
      enum "organization" {
        description
          "YANG statement 'organization'.";
      }
      enum "path" {
        description
          "YANG statement 'path'.";
      }
      enum "pattern" {
        description
          "YANG statement 'pattern'.";
      }
      enum "presence" {
        description
          "YANG statement 'presence'.";
      }
      enum "range" {
        description
          "YANG statement 'range'.";
      }
      enum "reference" {
        description
          "YANG statement 'reference'.";
      }
      enum "require-instance" {
        description
          "YANG statement 'require-instance'.";
      }
      enum "status" {
        description
          "YANG statement 'status'.";
      }
      enum "type" {
        description
          "YANG statement 'type'.";
      }
      enum "units" {
        description
          "YANG statement 'units'.";
      }
      enum "unique" {
        description
          "YANG statement 'unique'.";
      }
      enum "when" {
        description
          "YANG statement 'when'.";
      }
    }
    description
      "Type of the statement that a change affects.";
  }

  typedef revision-or-empty {
    type union {
      type empty;
      type yanglib:revision-identifier;
    }
    description
      "Module or submodule revision. If it has none, an empty value is
       used.";
  }

  grouping if-feature-stmts {
    description
      "Describes changes of all the if-features on a statement.";
    leaf-list if-feature {
      type string;
      description
        "Value of an if-feature statement.";
    }
  }

  grouping typedef-stmts {
    description
      "Describes changes of all the typedefs on a specific level and parent.";
    list typedef {
      key "name";
      description
        "List of typedefs.";
      leaf name {
        type yang:yang-identifier;
        description
          "Name of the typedef.";
      }
      leaf default {
        type string;
        description
          "List of default substatement values.";
      }
      leaf description {
        type string;
        description
          "Description substatement value.";
      }
      leaf reference {
        type string;
        description
          "Reference substatement value.";
      }
      uses status-stmt;
      container type {
        description
          "Type substatement.";
        uses type-substmts;
        list union-type {
          description
            "List of a union type substatements.";
          uses type-substmts;
        }
      }
      leaf units {
        type string;
        description
          "Units substatement value.";
      }
    }
  }

  grouping augment-stmt {
    description
      "Describes changes of an augment statement.";
    leaf target {
      type string;
      mandatory true;
      description
        "Augment target argument.";
    }
    uses node-info;
  }

  grouping augment-stmts {
    description
      "Describes changes of all the augment statements on a specific level and
       parent.";
    list augment {
      if-feature parsed-schema;
      description
        "List of augment substatements.";
      uses augment-stmt;
    }
  }

  grouping ext-instance-stmt {
    description
      "Describes changes of an extension instance.";
    leaf module {
      type yang:yang-identifier;
      mandatory true;
      description
        "Module with the extension definition of an extension instance.";
    }
    leaf name {
      type yang:yang-identifier;
      mandatory true;
      description
        "Name of the extension defition of an extension instance.";
    }
    leaf argument {
      type string;
      description
        "Argument used of an extension definition.";
    }
    anydata substatements {
      description
        "Any substatements of the extension instance.";
    }
  }

  grouping ext-instance-stmts {
    description
      "Describes changes of all the extension instances.";
    list ext-instance {
      description
        "List of extension-instance substatements.";
      uses ext-instance-stmt;
    }
  }

  grouping status-stmt {
    description
      "Describes a status statement change.";
    leaf status {
      type enumeration {
        enum "current" {
          description
            "Current effective status of a statement.";
        }
        enum "deprecated" {
          description
            "Deprecated effective status of a statement.";
        }
        enum "obsolete" {
          description
            "Obsolete effective status of a statement.";
        }
      }
      mandatory true;
      description
        "Status substatement value.";
    }
  }

  grouping must-stmts {
    description
      "Describes changes of all the must statements of a specific parent
       statement.";
    list must {
      description
        "List of must substatements.";
      leaf condition {
        type string;
        description
          "Condition substatement value.";
      }
      leaf description {
        type string;
        description
          "Description substatement value.";
      }
      leaf reference {
        type string;
        description
          "Reference substatement value.";
      }
      leaf error-message {
        type string;
        description
          "Error-message substatement value.";
      }
      leaf error-app-tag {
        type string;
        description
          "Error-app-tag substatement value.";
      }
      uses ext-instance-stmts;
    }
  }

  grouping when-stmts {
    description
      "Describes changes of all the must statements of a specific parent
       statement.";
    list when {
      description
        "List of when substatements.";
      leaf condition {
        type string;
        description
          "Condition substatement value.";
      }
      leaf description {
        type string;
        description
          "Description substatement value.";
      }
      leaf reference {
        type string;
        description
          "Reference substatement value.";
      }
      uses status-stmt;
      uses ext-instance-stmts;
    }
  }

  grouping restriction-substmts {
    description
      "Common substatements shared by all restriction statements.";
    leaf description {
      type string;
      description
        "Description substatement value.";
    }
    leaf reference {
      type string;
      description
        "Reference substatement value.";
    }
    leaf error-message {
      type string;
      description
        "Error-message substatement value.";
    }
    leaf error-app-tag {
      type string;
      description
        "Error-app-tag substatement value.";
    }
    uses ext-instance-stmts;
  }

  grouping type-substmts {
    description
      "Describes a type statement change.";
    leaf base-type {
      type enumeration {
        enum "int8" {
          description
            "YANG built-in type 'int8'.";
        }
        enum "int16" {
          description
            "YANG built-in type 'int16'.";
        }
        enum "int32" {
          description
            "YANG built-in type 'int32'.";
        }
        enum "int64" {
          description
            "YANG built-in type 'int64'.";
        }
        enum "uint8" {
          description
            "YANG built-in type 'uint8'.";
        }
        enum "uint16" {
          description
            "YANG built-in type 'uint16'.";
        }
        enum "uint32" {
          description
            "YANG built-in type 'uint32'.";
        }
        enum "uint64" {
          description
            "YANG built-in type 'uint64'.";
        }
        enum "decimal64" {
          description
            "YANG built-in type 'decimal64'.";
        }
        enum "string" {
          description
            "YANG built-in type 'string'.";
        }
        enum "boolean" {
          description
            "YANG built-in type 'boolean'.";
        }
        enum "enumeration" {
          description
            "YANG built-in type 'enumeration'.";
        }
        enum "bits" {
          description
            "YANG built-in type 'bits'.";
        }
        enum "binary" {
          description
            "YANG built-in type 'binary'.";
        }
        enum "leafref" {
          description
            "YANG built-in type 'leafref'.";
        }
        enum "identityref" {
          description
            "YANG built-in type 'identityref'.";
        }
        enum "empty" {
          description
            "YANG built-in type 'empty'.";
        }
        enum "union" {
          description
            "YANG built-in type 'union'.";
        }
        enum "instance-identifier" {
          description
            "YANG built-in type 'instance-identifier'.";
        }
      }
      description
        "Type substatement value.";
    }
    container range {
      description
        "Range statement substatements.";
      list interval {
        description
          "Intervals of a range statement.";
        leaf min {
          type int64;
          description
            "Lower boundary of an interval of a range statement.";
        }
        leaf max {
          type int64;
          description
            "Upper boundary of an interval of a range statement.";
        }
      }
      uses restriction-substmts;
    }
    container length {
      description
        "Length statement substatements.";
      list interval {
        description
          "Intervals of a length statement.";
        leaf min {
          type uint64;
          description
            "Lower boundary of an interval of a length statement.";
        }
        leaf max {
          type uint64;
          description
            "Upper boundary of an interval of a length statement.";
        }
      }
      uses restriction-substmts;
    }
    leaf fraction-digits {
      type uint8;
      description
        "Fraction-digits substatement value.";
    }
    list pattern {
      description
        "List of pattern statements.";
      leaf expression {
        type string;
        description
          "Pattern substatement value.";
      }
      leaf inverted {
        type boolean;
        description
          "Inverted substatement value.";
      }
      uses restriction-substmts;
    }
    list enum {
      key "name";
      ordered-by user;
      description
        "List of enum statements. Keeps the same order of the statements as in
         the module.";
      leaf name {
        type yang:yang-identifier;
        description
          "Enum statement name.";
      }
      uses if-feature-stmts {
        if-feature parsed-schema;
      }
      leaf description {
        type string;
        description
          "Description substatement value.";
      }
      leaf reference {
        type string;
        description
          "Reference substatement value.";
      }
      leaf value {
        type int32;
        description
          "Value substatement value.";
      }
      uses status-stmt;
      uses ext-instance-stmts;
    }
    list bit {
      key "name";
      ordered-by user;
      description
        "List of bit statements. Keeps the same order of the statements as in
         the module.";
      leaf name {
        type yang:yang-identifier;
        description
          "Bit statement name.";
      }
      uses if-feature-stmts {
        if-feature parsed-schema;
      }
      leaf description {
        type string;
        description
          "Description substatement value.";
      }
      leaf reference {
        type string;
        description
          "Reference substatement value.";
      }
      leaf position {
        type uint32;
        description
          "Position substatement value.";
      }
      uses status-stmt;
      uses ext-instance-stmts;
    }
    leaf path {
      type string;
      description
        "Path substatement value.";
    }
    leaf require-instance {
      type boolean;
      description
        "Require-instance substatement value.";
    }
    leaf-list base {
      type yang:yang-identifier;
      description
        "List of base substatement values.";
    }
    uses ext-instance-stmts;
  }

  grouping refine-deviate-node-substmts {
    description
      "All substatements of a data-definition node that can be changed by both
       a refine and deviate statement.";
    uses must-stmts;
    leaf-list default {
      type string;
      description
        "List of default substatement values.";
    }
    leaf config {
      type boolean;
      description
        "Config substatement value.";
    }
    leaf mandatory {
      type boolean;
      description
        "Mandatory substatement value.";
    }
    leaf min-elements {
      type uint32;
      description
        "Min-elements substatement value.";
    }
    leaf max-elements {
      type uint32;
      description
        "Max-elements substatement value.";
    }
  }

  grouping refine-node-substmts {
    description
      "All substatements of a data-definition node that can be changed by a
       refine statement.";
    uses if-feature-stmts {
      if-feature parsed-schema;
    }
    leaf presence {
      type boolean;
      description
        "Presence substatement existence.";
    }
    leaf description {
      type string;
      description
        "Description substatement value.";
    }
    leaf reference {
      type string;
      description
        "Reference substatement value.";
    }
    uses refine-deviate-node-substmts;
    uses ext-instance-stmts;
  }

  grouping deviate-only-node-substmts {
    description
      "All substatements of a data-definition node that can be changed only by
       a deviate statement.";
    container type {
      description
        "Type substatement.";
      uses type-substmts;
      list union-type {
        description
          "List of a union type substatements.";
        uses type-substmts;
      }
    }
    leaf units {
      type string;
      description
        "Units substatement value.";
    }
    list unique {
      description
        "List of unique substatements.";
      leaf-list node {
        type yang:yang-identifier;
        description
          "List of nodes referenced by a unique substatement.";
      }
    }
  }

  grouping node-substmts {
    description
      "All substatements of a data-definition node.";
    uses when-stmts;
    leaf-list key {
      type yang:yang-identifier;
      description
        "Leaf-list of nodes referenced by a key statement.";
    }
    leaf ordered-by {
      type enumeration {
        enum "system" {
          description
            "System-ordered list or leaf-list of items.";
        }
        enum "user" {
          description
            "User-ordered list or leaf-list of items.";
        }
      }
      description
        "Ordered-by substatement value.";
    }
    uses status-stmt;
    uses refine-node-substmts;
    uses deviate-only-node-substmts;
    uses typedef-stmts {
      if-feature parsed-schema;
    }
    anydata groupings {
      if-feature parsed-schema;
      description
        "Describes changes of all the augment statement on a specific level and
         parent. Follows the exact same YANG schema node structure as the
         grouping 'node-info'. There is no 'uses' statement to break a cyclic
         uses-grouping.";
    }
    anydata augments {
      if-feature parsed-schema;
      description
        "Describes changes of all the augment statement on a specific level and
         parent. Follows the exact same YANG schema node structure as the
         grouping 'augment-stmts'. There is no 'uses' statement to break a
         cyclic uses-grouping.";
    }
    list refine {
      if-feature parsed-schema;
      description
        "List of refine substatements.";
      leaf target {
        type string;
        mandatory true;
        description
          "Refine target path.";
      }
      uses refine-node-substmts;
    }
  }

  grouping module-substmts {
    description
      "All non-data-definition substatements of a module.";
    leaf prefix {
      if-feature parsed-schema;
      type string;
      description
        "Prefix substatement value.";
    }
    leaf organization {
      type string;
      description
        "Organization substatement value.";
    }
    leaf contact {
      type string;
      description
        "Contact substatement value.";
    }
    leaf description {
      type string;
      description
        "Description substatement value.";
    }
    leaf reference {
      type string;
      description
        "Reference substatement value.";
    }
    container extension {
      if-feature parsed-schema;
      presence
        "Exists only when there is a difference in this extension.";
      description
        "Extension substatements.";
      leaf name {
        type yang:yang-identifier;
        mandatory true;
        description
          "Extension name.";
      }
      leaf argument {
        type yang:yang-identifier;
        description
          "Argument substatement value.";
      }
      uses status-stmt;
      leaf description {
        type string;
        description
          "Description substatement value.";
      }
      leaf reference {
        type string;
        description
          "Reference substatement value.";
      }
    }
    container feature {
      if-feature parsed-schema;
      presence
        "Exists only when there is a difference in this feature.";
      description
        "Feature substatements.";
      leaf name {
        type yang:yang-identifier;
        mandatory true;
        description
          "Feature name.";
      }
      uses if-feature-stmts;
      uses status-stmt;
      leaf description {
        type string;
        description
          "Description substatement value.";
      }
      leaf reference {
        type string;
        description
          "Reference substatement value.";
      }
    }
    container identity {
      description
        "Identity substatements.";
      leaf name {
        type yang:yang-identifier;
        mandatory true;
        description
          "Identity statement name.";
      }
      uses if-feature-stmts {
        if-feature parsed-schema;
      }
      leaf-list base {
        if-feature parsed-schema;
        type yang:yang-identifier;
        description
          "List of bases of an identity.";
      }
      uses ext-instance-stmts;
    }
    container augment {
      if-feature parsed-schema;
      description
        "Augment substatements.";
      uses augment-stmt;
    }
    container deviation {
      if-feature parsed-schema;
      presence
        "Exists only when there is a difference in this deviation.";
      description
        "Deviation substatements.";
      leaf target {
        type string;
        mandatory true;
        description
          "Deviation target argument.";
      }
      list deviate {
        min-elements 1;
        description
          "List of deviate substatements.";
        leaf argument {
          type enumeration {
            enum not-supported {
              description
                "Deviate 'not-supported' argument value.";
            }
            enum add {
              description
                "Deviate 'add' argument value.";
            }
            enum replace {
              description
                "Deviate 'replace' argument value.";
            }
            enum delete {
              description
                "Deviate 'delete' argument value.";
            }
          }
          mandatory true;
          description
            "Deviate argument value.";
        }
        uses refine-deviate-node-substmts;
        uses deviate-only-node-substmts;
      }
      leaf description {
        type string;
        description
          "Description substatement value.";
      }
      leaf reference {
        type string;
        description
          "Reference substatement value.";
      }
    }
    uses typedef-stmts {
      if-feature parsed-schema;
    }
    container ext-instance {
      presence
        "Exists only when there is a difference in this extension-instance.";
      description
        "Extension-instance substatements.";
      uses ext-instance-stmt;
    }
  }

  grouping conformance-type {
    description
      "Conformance type of a change.";
    leaf conformance {
      type enumeration {
        enum "backwards-compatible" {
          description
            "Backwards-compatible or editorial change.";
        }
        enum "non-backwards-compatible" {
          description
            "Non-backwards-compatible change.";
        }
      }
      mandatory true;
      description
        "Conformance information of a change in the compared YANG modules.";
    }
  }

  grouping change-info {
    description
      "Details of a single change.";
    list changed {
      key "stmt";
      min-elements 1;
      description
        "List of changes.";
      leaf stmt {
        type stmt-type;
        description
          "Changed statement.";
      }
      leaf parent-stmt {
        type stmt-type;
        description
          "Parent statement of the changed statement.";
      }
      leaf change {
        type enumeration {
          enum "modified" {
            description
              "Statement existed and was modified.";
          }
          enum "added" {
            description
              "Statement was added.";
          }
          enum "removed" {
            description
              "Statement was removed.";
          }
          enum "moved" {
            description
              "Statement was moved and the position affects the meaning.";
          }
        }
        mandatory true;
        description
          "Type of change of the statement.";
      }
      uses conformance-type;
    }
  }

  grouping module-params {
    description
      "Identification details of a processed YANG module.";
    leaf module {
      type yang:yang-identifier;
      mandatory true;
      description
        "Compared module name.";
    }
    leaf revision {
      type revision-or-empty;
      mandatory true;
      description
        "Compared module revision.";
    }
    list submodule {
      key "name revision";
      leaf name {
        type yang:yang-identifier;
        mandatory true;
        description
          "Submodule name.";
      }
      leaf revision {
        type revision-or-empty;
        mandatory true;
        description
          "Submodule revision.";
      }
      description
        "Submodule of the main module.";
    }
    leaf-list enabled-feature {
      type yang:yang-identifier;
      description
        "All the enabled features of the module.";
    }
  }

  grouping node-info {
    description
      "Information about all the changed nodes.";
    list node-comparison {
      key "node";
      ordered-by user;
      description
        "Information about data-definition (node) statement substatement
         changes. Keeps the traversed order of the nodes by the algorithm.
         It SHOULD follow the depth-first search order.";
      leaf node {
        type schema-path;
        description
          "Path to the changed data-definition statement.";
      }
      leaf node-type {
        type enumeration {
          enum "container" {
            description
              "YANG statement 'container' node.";
          }
          enum "leaf" {
            description
              "YANG statement 'leaf' node.";
          }
          enum "leaf-list" {
            description
              "YANG statement 'leaf-list' node.";
          }
          enum "list" {
            description
              "YANG statement 'list' node.";
          }
          enum "anydata" {
            description
              "YANG statement 'anydata' node.";
          }
          enum "anyxml" {
            description
              "YANG statement 'anyxml' node.";
          }
          enum "rpc" {
            description
              "YANG statement 'rpc' node.";
          }
          enum "action" {
            description
              "YANG statement 'action' node.";
          }
          enum "notification" {
            description
              "YANG statement 'notification' node.";
          }
          enum "choice" {
            if-feature parsed-schema;
            description
              "YANG statement 'choice' node.";
          }
          enum "case" {
            if-feature parsed-schema;
            description
              "YANG statement 'case' node.";
          }
          enum "uses" {
            if-feature parsed-schema;
            description
              "YANG statement 'uses' node.";
          }
          enum "grouping" {
            if-feature parsed-schema;
            description
              "YANG statement 'grouping' node.";
          }
        }
        mandatory true;
        description
          "Type of the changed data-definition statement.";
      }
      uses change-info;
      container old {
        description
          "All the node substatements in the older revision of the YANG
           module.";
        uses node-substmts;
      }
      container new {
        description
          "All the node substatements in the newer revision of the YANG
           module.";
        uses node-substmts;
      }
    }
  }

  sx:structure schema-comparison {
    description
      "Schema comparison details.";
    list schema {
      description
        "Instance of a schema comparison of 2 YANG modules in different
         revisions with all their imports.";
      container source {
        description
          "Source module information.";
        uses module-params;
      }
      list source-import {
        key "module revision";
        description
          "List of source module imported modules information.";
        uses module-params;
      }
      container target {
        description
          "Target module information.";
        uses module-params;
      }
      list target-import {
        key "module revision";
        description
          "List of target module imported modules information.";
        uses module-params;
      }
      uses conformance-type;
      list module-comparison {
        description
          "Information about direct module statement substatement changes.";
        uses change-info;
        container old {
          description
            "Changed statements in the older revision of the YANG module.";
          uses module-substmts;
        }
        container new {
          description
            "Changed statements in the newer revision of the YANG module.";
          uses module-substmts;
        }
      }
      uses node-info;
    }
  }
}
